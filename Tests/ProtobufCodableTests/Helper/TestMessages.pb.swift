// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TestMessages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct PB_BasicMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var double: Double = 0

  var float: Float = 0

  var int32: Int32 = 0

  var int64: Int64 = 0

  var unsignedInt32: UInt32 = 0

  var unsignedInt64: UInt64 = 0

  var signedInt32: Int32 = 0

  var signedInt64: Int64 = 0

  var fixedInt32: UInt32 = 0

  var fixedInt64: UInt64 = 0

  var signedFixedInt32: Int32 = 0

  var signedFixedInt64: Int64 = 0

  var boolean: Bool = false

  var string: String = String()

  var bytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_NestedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var basic: PB_BasicMessage {
    get {return _storage._basic ?? PB_BasicMessage()}
    set {_uniqueStorage()._basic = newValue}
  }
  /// Returns true if `basic` has been explicitly set.
  var hasBasic: Bool {return _storage._basic != nil}
  /// Clears the value of `basic`. Subsequent reads from it will return its default value.
  mutating func clearBasic() {_uniqueStorage()._basic = nil}

  var nested: PB_NestedMessage.Nested {
    get {return _storage._nested ?? PB_NestedMessage.Nested()}
    set {_uniqueStorage()._nested = newValue}
  }
  /// Returns true if `nested` has been explicitly set.
  var hasNested: Bool {return _storage._nested != nil}
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  mutating func clearNested() {_uniqueStorage()._nested = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Nested {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var double: Double = 0

    var uint: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PB_DeepNestedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var basic: PB_BasicMessage {
    get {return _basic ?? PB_BasicMessage()}
    set {_basic = newValue}
  }
  /// Returns true if `basic` has been explicitly set.
  var hasBasic: Bool {return self._basic != nil}
  /// Clears the value of `basic`. Subsequent reads from it will return its default value.
  mutating func clearBasic() {self._basic = nil}

  var nested: PB_NestedMessage {
    get {return _nested ?? PB_NestedMessage()}
    set {_nested = newValue}
  }
  /// Returns true if `nested` has been explicitly set.
  var hasNested: Bool {return self._nested != nil}
  /// Clears the value of `nested`. Subsequent reads from it will return its default value.
  mutating func clearNested() {self._nested = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _basic: PB_BasicMessage? = nil
  fileprivate var _nested: PB_NestedMessage? = nil
}

struct PB_Repeated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unsigneds: [UInt32] = []

  var messages: [PB_BasicMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_DictContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stringDict: Dictionary<String,Int32> = [:]

  var uintDict: Dictionary<UInt32,PB_BasicMessage> = [:]

  var intDict: Dictionary<Int64,PB_BasicMessage> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PB"

extension PB_BasicMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BasicMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "double"),
    2: .same(proto: "float"),
    3: .same(proto: "int32"),
    4: .same(proto: "int64"),
    5: .same(proto: "unsignedInt32"),
    6: .same(proto: "unsignedInt64"),
    7: .same(proto: "signedInt32"),
    8: .same(proto: "signedInt64"),
    9: .same(proto: "fixedInt32"),
    10: .same(proto: "fixedInt64"),
    11: .same(proto: "signedFixedInt32"),
    12: .same(proto: "signedFixedInt64"),
    13: .same(proto: "boolean"),
    14: .same(proto: "string"),
    15: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.double) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.float) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.int32) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.int64) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.unsignedInt32) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.unsignedInt64) }()
      case 7: try { try decoder.decodeSingularSInt32Field(value: &self.signedInt32) }()
      case 8: try { try decoder.decodeSingularSInt64Field(value: &self.signedInt64) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self.fixedInt32) }()
      case 10: try { try decoder.decodeSingularFixed64Field(value: &self.fixedInt64) }()
      case 11: try { try decoder.decodeSingularSFixed32Field(value: &self.signedFixedInt32) }()
      case 12: try { try decoder.decodeSingularSFixed64Field(value: &self.signedFixedInt64) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.boolean) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.string) }()
      case 15: try { try decoder.decodeSingularBytesField(value: &self.bytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.double != 0 {
      try visitor.visitSingularDoubleField(value: self.double, fieldNumber: 1)
    }
    if self.float != 0 {
      try visitor.visitSingularFloatField(value: self.float, fieldNumber: 2)
    }
    if self.int32 != 0 {
      try visitor.visitSingularInt32Field(value: self.int32, fieldNumber: 3)
    }
    if self.int64 != 0 {
      try visitor.visitSingularInt64Field(value: self.int64, fieldNumber: 4)
    }
    if self.unsignedInt32 != 0 {
      try visitor.visitSingularUInt32Field(value: self.unsignedInt32, fieldNumber: 5)
    }
    if self.unsignedInt64 != 0 {
      try visitor.visitSingularUInt64Field(value: self.unsignedInt64, fieldNumber: 6)
    }
    if self.signedInt32 != 0 {
      try visitor.visitSingularSInt32Field(value: self.signedInt32, fieldNumber: 7)
    }
    if self.signedInt64 != 0 {
      try visitor.visitSingularSInt64Field(value: self.signedInt64, fieldNumber: 8)
    }
    if self.fixedInt32 != 0 {
      try visitor.visitSingularFixed32Field(value: self.fixedInt32, fieldNumber: 9)
    }
    if self.fixedInt64 != 0 {
      try visitor.visitSingularFixed64Field(value: self.fixedInt64, fieldNumber: 10)
    }
    if self.signedFixedInt32 != 0 {
      try visitor.visitSingularSFixed32Field(value: self.signedFixedInt32, fieldNumber: 11)
    }
    if self.signedFixedInt64 != 0 {
      try visitor.visitSingularSFixed64Field(value: self.signedFixedInt64, fieldNumber: 12)
    }
    if self.boolean != false {
      try visitor.visitSingularBoolField(value: self.boolean, fieldNumber: 13)
    }
    if !self.string.isEmpty {
      try visitor.visitSingularStringField(value: self.string, fieldNumber: 14)
    }
    if !self.bytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytes, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_BasicMessage, rhs: PB_BasicMessage) -> Bool {
    if lhs.double != rhs.double {return false}
    if lhs.float != rhs.float {return false}
    if lhs.int32 != rhs.int32 {return false}
    if lhs.int64 != rhs.int64 {return false}
    if lhs.unsignedInt32 != rhs.unsignedInt32 {return false}
    if lhs.unsignedInt64 != rhs.unsignedInt64 {return false}
    if lhs.signedInt32 != rhs.signedInt32 {return false}
    if lhs.signedInt64 != rhs.signedInt64 {return false}
    if lhs.fixedInt32 != rhs.fixedInt32 {return false}
    if lhs.fixedInt64 != rhs.fixedInt64 {return false}
    if lhs.signedFixedInt32 != rhs.signedFixedInt32 {return false}
    if lhs.signedFixedInt64 != rhs.signedFixedInt64 {return false}
    if lhs.boolean != rhs.boolean {return false}
    if lhs.string != rhs.string {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_NestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NestedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "basic"),
    2: .same(proto: "nested"),
  ]

  fileprivate class _StorageClass {
    var _basic: PB_BasicMessage? = nil
    var _nested: PB_NestedMessage.Nested? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _basic = source._basic
      _nested = source._nested
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._basic) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nested) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._basic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._nested {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_NestedMessage, rhs: PB_NestedMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._basic != rhs_storage._basic {return false}
        if _storage._nested != rhs_storage._nested {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_NestedMessage.Nested: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = PB_NestedMessage.protoMessageName + ".Nested"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "double"),
    2: .same(proto: "uint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.double) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.uint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.double != 0 {
      try visitor.visitSingularDoubleField(value: self.double, fieldNumber: 1)
    }
    if self.uint != 0 {
      try visitor.visitSingularUInt32Field(value: self.uint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_NestedMessage.Nested, rhs: PB_NestedMessage.Nested) -> Bool {
    if lhs.double != rhs.double {return false}
    if lhs.uint != rhs.uint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_DeepNestedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeepNestedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "basic"),
    2: .same(proto: "nested"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._basic) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nested) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._basic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._nested {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_DeepNestedMessage, rhs: PB_DeepNestedMessage) -> Bool {
    if lhs._basic != rhs._basic {return false}
    if lhs._nested != rhs._nested {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Repeated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Repeated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unsigneds"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.unsigneds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unsigneds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.unsigneds, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Repeated, rhs: PB_Repeated) -> Bool {
    if lhs.unsigneds != rhs.unsigneds {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_DictContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DictContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stringDict"),
    2: .same(proto: "uintDict"),
    3: .same(proto: "intDict"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.stringDict) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,PB_BasicMessage>.self, value: &self.uintDict) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,PB_BasicMessage>.self, value: &self.intDict) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stringDict.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.stringDict, fieldNumber: 1)
    }
    if !self.uintDict.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,PB_BasicMessage>.self, value: self.uintDict, fieldNumber: 2)
    }
    if !self.intDict.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,PB_BasicMessage>.self, value: self.intDict, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_DictContainer, rhs: PB_DictContainer) -> Bool {
    if lhs.stringDict != rhs.stringDict {return false}
    if lhs.uintDict != rhs.uintDict {return false}
    if lhs.intDict != rhs.intDict {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
