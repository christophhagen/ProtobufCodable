# ProtobufCodable

A binary encoder for Swift `Codable` types. Convert objects to binary data, which can be compliant with the [Google Protocol Buffer](https://developers.google.com/protocol-buffers) format for compatible data types. It can also encode additional types unsupported by Protobuf, such as optionals, single values, arrays, sets, enums, and dictionaries.

## Why?

Considering that Apple itself provides an implementation to use [Google Protocol Buffers in Swift](https://github.com/apple/swift-protobuf), why is there a need to provide another library for binary encoding/decoding with the same format?

* **Features**: `ProtobufCodable` provides support for more features compared to protocol buffers, including `Optional` types, as well as directly encoding dictionaries, single values, arrays, sets, enums, and dictionaries. 
* **Ease of use**: Using protobuf objects for encoding and decoding requires you to define separate messages for decoding and encoding, with a lot of code to convert data between representations. `ProtobufCodable` works with all types that conforming to `Codable`, so there's no need to write additional code.
* **Swifty**: `swift-protobuf` requires you to define your message definitions in a `.proto` file and compile it using the protobuf compiler whenever your definitions change. `ProtobufCodable` works right within Swift, and hooks into your already existing messages.
* **Freedom**: The message definitions generated by `swift-protobuf` are always `internal` structs, which prevents them from being exposed by frameworks, and prevents inheritance. With `ProtobufCodable`, you're free to use classes, as well as `public` modifiers.
* **Compatibility**: `ProtobufCodable` gives you a lot of options, but still [maintains compatibility](#protobuf-compatibility) with protobuf where possible. When you design your types accordingly, you can use `ProtobufCodable` in Swift, and protobuf everywhere else.

# Installation

## Swift Package Manager

Simply include in your `Package.swift`:
```swift
dependencies: [
    .package(name: "ProtobufCodable", url: "https://github.com/christophhagen/ProtobufCodable", from: "0.3.0")
],
targets: [
    .target(name: "MyTarget", dependencies: ["ProtobufCodable"])
]
```

## Xcode project

Select your `Project`, navigate to the `Package Dependencies` tab, and add `https://github.com/christophhagen/ProtobufCodable` using the `+` button.

# Usage

Let's assume a message definition: 

```swift
struct Message: Codable {

    var sender: String
    
    var isRead: Bool
    
    var unreadCount: Int
}
```

Simply import the module when you need to encode or decode a message:

```swift
import ProtobufCodable
```

## Encoding

Construct an encoder when converting instances to binary data, and feed the message(s) into it:

```swift
let message = Message(...)

let encoder = ProtobufEncoder()
let data = try encoder.encode(message)
```

It's also possible to encode single values, arrays, optionals, sets, enums, and dictionaries, so long as they conform to `Codable`.

## Decoding

Decoding instances from binary data works much the same way:

```swift
let decoder = ProtobufDecoder()
let message = decoder.decode(Message.self, from: data)
```

Alternatively, the type can be inferred:

```swift
let message: Message = decoder.decode(from: data)
```

## Coding Keys

The `Codable` protocol uses [CodingKey](https://developer.apple.com/documentation/swift/codingkey) definitions to identify properties of instances. By default, coding keys are generated using the string values of the property names.

Similar to JSON encoding, `ProtobufCodable` can embed the property names in the encoded data.

Unlike JSON (which is human-readable), the binary representation produced by `ProtobufCodable` is intended for cases when efficient encoding is important. `Codable` allows the use of integer keys for each property by adding an enum conforming to the `CodingKey` protocol to the `Codable` type:

```swift
struct Message: Codable {

    enum CodingKeys: Int, CodingKey {
        case sender = 1
        case isRead = 2
        case unreadCount = 3
    }

    var sender: String
    
    var isRead: Bool
    
    var unreadCount: Int
}
```
The enum must have a raw value of either `Int` or `String`, and the cases must match the property names within the type (it is possible to omit keys for properties which should not be encoded).

Using integer keys can significantly decrease the binary size, especially for long property names. Integer coding keys are also required to achieve compatibility with Google's [Protocol Buffers](https://developers.google.com/protocol-buffers), which also uses (positive) integer keys for each field.

Additionally, integer keys can be useful when intending to store the binary data persistently. Changes to property names can be performed in the code without breaking the decoding of older data (although this can also be achieved with custom `String` keys).

## Encoding Options

There is different encoding options available to adjust the behaviour of the encoding process. These options can be specified on the `ProtobufEncoder` struct after creating it.

### Omit default values

The Protobuf specification defines [default values](https://developers.google.com/protocol-buffers/docs/proto3#default) for different message types, which are assumed if an encoded message does not contain a particular singular element. This can reduce the binary size when often encoding default values within objects. `ProtobufEncoder` does **not** use this feature by default. This is because `ProtobufCodable` supports Swift's `Optional` values, which are decoded as `nil` if no data is present for the value. The `Codable` implementation does not allow the encoder to distinguish between optional and non-optional fields, so all default values are encoded by default. This still maintains full compatibility with Protobuf, since it doesn't have optional values (in the Swift sense), and default values which are present in binary data are decoded normally.

If you want to gain the efficiency boost of omitted default values, specify the `omitDefaultValues` option for the encoder:
```swift
var encoder = ProtobufEncoder()
encoder.omitDefaultValues = true
```

Note that this option should only be used for objects without `Optional` fields to maintain consistency: **Any default value within an optional field will be decoded as `nil` when specifying the `omitDefaultValues` option**

### Require integer coding keys

As specified in [Coding Keys](#coding-keys), integer values reduces the binary size and is also required to achieve [compatibility with Google Protobuf](#protobuf-compatibility). It is therefore possible to produce runtime errors when encoding an object which does not specify integer coding keys for all properties:
```swift
var encoder = ProtobufEncoder()
encoder.requireIntegerCodingKeys = true
```

Encoding non-compliant objects will result in an error of type `ProtobufEncodingError.missingIntegerCodingKey`

# Protobuf Compatibility

`ProtobufCodable` aims to provide compatibility with Google's [Protocol Buffers](https://developers.google.com/protocol-buffers) wherever possible. This isn't possible in all cases, since not all Swift features are available in Protobuf, and vice versa.

## Supported types

Protobuf messages are constructed from a limited set of primitives (aka *scalar types*), which are listed in the [official documentation](https://developers.google.com/protocol-buffers/docs/proto3#scalar).

| Protobuf primitive | ProtobufCodable type | Comment |
| :-- | :-- | :-- |
`double` | `Double` | Always 8 bytes
`float` | `Float` | Always 4 bytes
`int32` | `Int32` | Uses variable-length encoding
`int64` | `Int64` | Uses variable-length encoding
`uint32` | `UInt32` | Uses variable-length encoding
`uint64` | `UInt64` | Uses variable-length encoding
`sint32` | `Signed<Int32>` | See [`SignedValue` wrapper](#signed-types)
`sint64` | `Signed<Int64>` |  See [`SignedValue` wrapper](#signed-types)
`fixed32` | `FixedWidth<UInt32>` | See [`FixedWidth` wrapper](#fixed-width-types)
`fixed64` | `FixedWidth<UInt64>` | See [`FixedWidth` wrapper](#fixed-width-types)
`sfixed32` | `FixedWidth<Int32>` | See [`FixedWidth` wrapper](#fixed-width-types)
`sfixed64` | `FixedWidth<Int64>` | See [`FixedWidth` wrapper](#fixed-width-types)
`bool` | `Bool` | Always 1 byte
`string` | `String` | Encoded using UTF-8
`bytes` | `Data` | Encoded as-is

### Supported features

Protobuf primitive | ProtobufCodable equivalent
------------------ | :---------
`repeated type`  | `Array<Type> where Type: Codable` | Fully supported
`map<key,value>` | `Dictionary<Key,Value>` | Fully supported
nested types | nested `Codable` type
`oneof` | Not supported, no straight-forward equivalent
`enum` | Not supported
`Any` | Not supported
groups | Not supported

### Example

Let's consider the protobuf definition:

```protobuf
syntax = "proto3";
package PB;

message BookInfo {
   fixed64 id = 1;
   string title = 2;
   repeated string authors = 3;
}
```

An equivalent and compatible Swift type would be:
```swift
struct BookInfo: Codable {
   @FixedWidth var id: UInt64
   var title: String
   var authors: [String]
   
   enum CodingKeys: Int, CodingKey {
      case id = 1
      case title = 2
      case authors = 3
   }
}
```

It's then possible to use both interchangeably:
```swift
let info = PB_BookInfo(...)
let data = try PB_BookInfo.serializedData()
let decodedInfo = try ProtobufDecoder.decode(BookInfo.self, from: data)
```

## Wrappers

Protobuf encodes integers using [Base 128 variable-length encoding](https://developers.google.com/protocol-buffers/docs/encoding#varints), where smaller values require less bytes to encode. This encoding style is often beneficial, especially when mostly encoding small values. For other cases, different encoding styles may be more optimal.

In order to specify an encoding of integers other than the standard, use one of the property wrappers below.
 
### Fixed-width types

The `@FixedWidth` propery wrapper forces integers to always be encoded using their full width, e.g. using 4 bytes to encode a `UInt32`. In order to apply it to a property, simply specify the wrapper with the property definition:

```swift
struct MyCodable: Codable {

    /// Always encoded as 8 bytes
    @FixedWidth
    var largeInteger: Int64
}
```

The `FixedWidth` wrapper works with `Int16`, `Int32`, `Int64`, `UInt16`, `UInt32`, and `UInt64`.

### Signed types

While the standard variable-length encoding is efficient for small positive values, negative values are encoded with a lot of overhead. To mitigate this, use the `SignedValue` wrapper:

```swift
struct MyCodable: Codable {

    /// Encodes negative values more efficiently
    @SignedValue
    var largeInteger: Int64
}
```

The `SignedValue` wrapper work with `Int16`, `Int32`, and `Int64`

## Merging

Protocol Buffers support the [merging of messages](https://developers.google.com/protocol-buffers/docs/encoding#optional), which overwrites non-repeated fields, and concatenates repeated fields.

`ProtobufCodable` also supports this feature in most cases. This feature is still under development, and should be used with caution.

## Errors

It is possible for both encoding and decoding to fail. 

All possible errors occuring during encoding produce `ProtobufEncodingError` errors, while unsuccessful decoding produces `ProtobufDecodingError`s. Both are enums with several cases describing the nature of the error. See the documentation of the types to learn more about the different error conditions.

# Roadmap

## Check protobuf compatibility

In the future, a runtime feature should be added to check if a type can be fully represented as a Protobuf message. This function should check the `Codable` type for any features (like `Optional`s or `String` keys), which can't be decoded by official Protobuf decoders.

## Generate protobuf definitions

Based on the check for protobuf compatibility, it should be possible to generate a string containing a working Protobuf definition for any type that is determined to be Protobuf compatible.


